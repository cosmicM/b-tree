{"version":3,"file":"btree.esm.js","sources":["../src/btree_node.ts","../src/btree.ts"],"sourcesContent":["import { Key, Value, Comparator, Visitor } from './types';\n\nexport default class BTreeNode<Key, Value> {\n\n  leaf: boolean;\n  keys: Array<Key>;\n  data: Array<Value>;\n  n: number;\n  C: Array<BTreeNode<Key,Value>>;\n\n  constructor (t:number, isLeaf:boolean) {\n    // Copy the given minimum degree and leaf property\n    this.leaf = isLeaf; // Is true when node is leaf. Otherwise false\n\n    // Allocate memory for maximum number of possible keys\n    // and child pointers\n    this.keys = new Array(2 * t - 1); // An array of keys\n    this.data = new Array(2 * t - 1);\n    this.C    = new Array(2 * t); // An array of child pointers\n\n    this.n    = 0; // Current number of keys\n  }\n\n\n  // Function to traverse all nodes in a subtree rooted with this node\n  traverse (visitor: Visitor<Key, Value>) {\n    // There are n keys and n+1 children, travers through n keys\n    // and first n children\n    const C    = this.C;\n    const keys = this.keys;\n    const data = this.data;\n    let i;\n    for (i = 0; i < this.n; i++) {\n      // If this is not leaf, then before printing key[i],\n      // traverse the subtree rooted with child C[i].\n      if (!this.leaf) C[i].traverse(visitor);\n      visitor(keys[i], data[i]);\n    }\n\n    // Print the subtree rooted with last child\n    if (!this.leaf) C[i].traverse(visitor);\n  }\n\n\n  // Function to search key k in subtree rooted with this node\n  search (key:Key, comparator: Comparator<Key>):BTreeNode<Key, Value> {\n    // Find the first key greater than or equal to k\n    let i = 0;\n    const keys = this.keys;\n    while (i < this.n && comparator(key, keys[i]) > 0) i++;\n\n    // If the found key is equal to k, return this node\n    if (comparator(keys[i], key) === 0) return this;\n\n    // If key is not found here and this is a leaf node\n    if (this.leaf) return null;\n\n    // Go to the appropriate child\n    return this.C[i].search(key, comparator);\n  }\n\n\n  // A utility function that returns the index of the first key that is\n  // greater than or equal to k\n  findKey (key:Key, comparator:Comparator<Key>):number {\n    let idx = 0;\n    while (idx < this.n && comparator(this.keys[idx], key) < 0) idx++;\n    return idx;\n  }\n\n\n  // A utility function to insert a new key in this node\n  // The assumption is, the node must be non-full when this\n  // function is called\n  insertNonFull (k:Key, value:Value, comparator:Comparator<Key>, t:number) {\n    // Initialize index as index of rightmost element\n    let i      = this.n - 1;\n    const keys = this.keys;\n    const data = this.data;\n    const C    = this.C;\n\n    // If this is a leaf node\n    if (this.leaf) {\n      // The following loop does two things\n      // a) Finds the location of new key to be inserted\n      // b) Moves all greater keys to one place ahead\n      while (i >= 0 && comparator(keys[i], k) > 0) {\n        keys[i + 1] = keys[i];\n        data[i + 1] = data[i];\n        i--;\n      }\n\n      // Insert the new key at found location\n      keys[i + 1] = k;\n      data[i + 1] = value;\n      this.n++;\n    } else { // If this node is not leaf\n      // Find the child which is going to have the new key\n      while (i >= 0 && comparator(keys[i], k) > 0) i--;\n\n      // See if the found child is full\n      if (C[i + 1].n === 2 * t - 1) {\n        // If the child is full, then split it\n        this.splitChild(i + 1, C[i + 1], t);\n        // After split, the middle key of C[i] goes up and\n        // C[i] is splitted into two.  See which of the two\n        // is going to have the new key\n        if (comparator(keys[i + 1], k) < 0) i++;\n      }\n      C[i + 1].insertNonFull(k, value, comparator, t);\n    }\n  }\n\n\n  // A utility function to split the child y of this node\n  // Note that y must be full when this function is called\n  splitChild (i:number, y:BTreeNode<Key,Value>, t:number) {\n    const n = this.n;\n    const C = this.C;\n    const data = this.data;\n    const keys = this.keys;\n\n    // Create a new node which is going to store (t-1) keys of y\n    const z = new BTreeNode<Key,Value>(t, y.leaf);\n    z.n = t - 1;\n\n    // Copy the last (t-1) keys of y to z\n    for (let j = 0; j < t - 1; j++) {\n      z.keys[j] = y.keys[j + t];\n      z.data[j] = y.data[j + t];\n    }\n\n    // Copy the last t children of y to z\n    if (!y.leaf) {\n      for (let j = 0; j < t; j++) z.C[j] = y.C[j + t];\n    }\n\n    // Reduce the number of keys in y\n    y.n = t - 1;\n\n    // Since this node is going to have a new child,\n    // create space of new child\n    for (let j = n; j >= i + 1; j--) C[j + 1] = C[j];\n\n    // Link the new child to this node\n    C[i + 1] = z;\n\n    // A key of y will move to this node. Find location of\n    // new key and move all greater keys one space ahead\n    for (let j = n - 1; j >= i; j--) {\n      keys[j + 1] = keys[j];\n      data[j + 1] = data[j];\n    }\n\n    // Copy the middle key of y to this node\n    keys[i] = y.keys[t - 1];\n    data[i] = y.data[t - 1];\n\n    // Increment count of keys in this node\n    this.n = n + 1;\n  }\n\n\n  // A function to remove the key k from the sub-tree rooted with this node\n  remove (k:Key, comparator:Comparator<Key>, t:number) {\n    let idx    = this.findKey(k, comparator);\n    const n    = this.n;\n    const keys = this.keys;\n    const C    = this.C;\n\n    // The key to be removed is present in this node\n    if (idx < n && comparator(keys[idx], k) === 0) {\n      // If the node is a leaf node - removeFromLeaf is called\n      // Otherwise, removeFromNonLeaf function is called\n      if (this.leaf) this.removeFromLeaf(idx);\n      else           this.removeFromNonLeaf(idx, comparator, t);\n    } else {\n\n      // If this node is a leaf node, then the key is not present in tree\n      if (this.leaf) throw new Error(`The key \"${k}\" is does not exist in the tree`);\n\n\n      // The key to be removed is present in the sub-tree rooted with this node\n      // The flag indicates whether the key is present in the sub-tree rooted\n      // with the last child of this node\n      const flag = (idx === n);\n\n      // If the child where the key is supposed to exist has less that t keys,\n      // we fill that child\n      if (C[idx].n < t) this.fill(idx, t);\n\n      // If the last child has been merged, it must have merged with the previous\n      // child and so we recurse on the (idx-1)th child. Else, we recurse on the\n      // (idx)th child which now has atleast t keys\n      if (flag && idx > n) C[idx - 1].remove(k, comparator, t);\n      else                 C[idx].remove(k, comparator, t);\n    }\n  }\n\n\n  // A function to remove the idx-th key from this node - which is a leaf node\n  removeFromLeaf (idx:number) {\n    // Move all the keys after the idx-th pos one place backward\n    const keys = this.keys;\n    const data = this.data;\n    for (let i = idx + 1; i < this.n; i++) {\n      keys[i - 1] = keys[i];\n      data[i - 1] = data[i];\n    }\n    // Reduce the count of keys\n    this.n--;\n  }\n\n\n  // A function to remove the idx-th key from this node - which is a non-leaf node\n  removeFromNonLeaf(idx:number, comparator:Comparator<Key>, t:number) {\n    const keys = this.keys;\n    const data = this.data;\n    const C    = this.C;\n\n    let k:Key   = keys[idx];\n\n\n    // If the child that precedes k (C[idx]) has atleast t keys,\n    // find the predecessor 'pred' of k in the subtree rooted at\n    // C[idx]. Replace k by pred. Recursively delete pred\n    // in C[idx]\n    if (C[idx].n >= t) {\n      let cur = C[idx];\n      while (!cur.leaf) cur = cur.C[cur.n];\n      const predKey  = cur.keys[cur.n - 1];\n      keys[idx] = predKey;\n      data[idx] = cur.data[cur.n - 1];\n      C[idx].remove(predKey, comparator, t);\n    } else if (C[idx + 1].n >= t) {\n      // If the child C[idx] has less that t keys, examine C[idx+1].\n      // If C[idx+1] has atleast t keys, find the successor 'succ' of k in\n      // the subtree rooted at C[idx+1]\n      // Replace k by succ\n      // Recursively delete succ in C[idx+1]\n      let cur = C[idx+1];\n      while (!cur.leaf) cur = cur.C[0];\n      // Return the first key of the leaf\n      const succKey = cur.keys[0];\n      const succData = cur.data[0];\n      keys[idx] = succKey;\n      data[idx] = cur.data[0];\n      C[idx + 1].remove(succKey, comparator, t);\n    } else {\n      // If both C[idx] and C[idx+1] has less that t keys,merge k and all of C[idx+1]\n      // into C[idx]\n      // Now C[idx] contains 2t-1 keys\n      // Free C[idx+1] and recursively delete k from C[idx]\n      this.merge(idx, t);\n      C[idx].remove(k, comparator, t);\n    }\n  }\n\n\n  // A function to get predecessor of keys[idx]\n  prev(idx:number):Key {\n    // Keep moving to the right most node until we reach a leaf\n    const C = this.C;\n    let cur = C[idx];\n    while (!cur.leaf) cur = cur.C[cur.n];\n    // Return the last key of the leaf\n    return cur.keys[cur.n - 1];\n  }\n\n\n  next(idx:number):Key {\n    // Keep moving the left most node starting from C[idx+1] until we reach a leaf\n    const C = this.C;\n    let cur = C[idx+1];\n    while (!cur.leaf) cur = cur.C[0];\n    // Return the first key of the leaf\n    return cur.keys[0];\n  }\n\n\n  // A function to fill child C[idx] which has less than t-1 keys\n  fill(idx:number, t:number) {\n    const n = this.n;\n    const C = this.C;\n    // If the previous child(C[idx-1]) has more than t-1 keys, borrow a key\n    // from that child\n    if (idx !== 0 && C[idx - 1].n >= t)      this.borrowFromPrev(idx);\n\n    // If the next child(C[idx+1]) has more than t-1 keys, borrow a key\n    // from that child\n    else if (idx !== n && C[idx + 1].n >= t) this.borrowFromNext(idx);\n\n    // Merge C[idx] with its sibling\n    // If C[idx] is the last child, merge it with with its previous sibling\n    // Otherwise merge it with its next sibling\n    else {\n      if (idx !== n) this.merge(idx,     t);\n      else           this.merge(idx - 1, t);\n    }\n  }\n\n\n  // A function to borrow a key from C[idx-1] and insert it\n  // into C[idx]\n  borrowFromPrev(idx:number) {\n    const C       = this.C;\n    const keys    = this.keys;\n    const data    = this.data;\n    const child   = C[idx];\n    const sibling = C[idx - 1];\n\n    // The last key from C[idx-1] goes up to the parent and key[idx-1]\n    // from parent is inserted as the first key in C[idx]. Thus, the  loses\n    // sibling one key and child gains one key\n\n    // Moving all key in C[idx] one step ahead\n    for (let i = child.n - 1; i >= 0; i--) {\n      child.keys[i + 1] = child.keys[i];\n      child.data[i + 1] = child.data[i];\n    }\n\n    // If C[idx] is not a leaf, move all its child pointers one step ahead\n    if (!child.leaf) {\n      for (let i = child.n; i >= 0; i--) child.C[i + 1] = child.C[i];\n    }\n\n    // Setting child's first key equal to keys[idx-1] from the current node\n    child.keys[0] = keys[idx - 1];\n    child.data[0] = data[idx - 1];\n\n    // Moving sibling's last child as C[idx]'s first child\n    if (!this.leaf) child.C[0] = sibling.C[sibling.n];\n\n    // Moving the key from the sibling to the parent\n    // This reduces the number of keys in the sibling\n    keys[idx - 1] = sibling.keys[sibling.n - 1];\n    data[idx - 1] = sibling.data[sibling.n - 1];\n\n    child.n++;\n    sibling.n--;\n  }\n\n  // A function to borrow a key from the C[idx+1] and place\n  // it in C[idx]\n  borrowFromNext (idx:number) {\n    const C       = this.C;\n    const keys    = this.keys;\n    const data    = this.data;\n\n    const child:BTreeNode<Key,Value>   = C[idx];\n    const sibling:BTreeNode<Key,Value> = C[idx + 1];\n\n    // keys[idx] is inserted as the last key in C[idx]\n    child.keys[child.n] = keys[idx];\n    child.data[child.n] = data[idx];\n\n    // Sibling's first child is inserted as the last child\n    // into C[idx]\n    if (!child.leaf) child.C[child.n + 1] = sibling.C[0];\n\n    //The first key from sibling is inserted into keys[idx]\n    keys[idx] = sibling.keys[0];\n    data[idx] = sibling.data[0];\n\n    // Moving all keys in sibling one step behind\n    for (let i = 1; i < sibling.n; i++) {\n      sibling.keys[i - 1] = sibling.keys[i];\n      sibling.data[i - 1] = sibling.data[i];\n    }\n\n    // Moving the child pointers one step behind\n    if (!sibling.leaf) {\n      for (let i = 1; i <= sibling.n; i++) sibling.C[i - 1] = sibling.C[i];\n    }\n\n    // Increasing and decreasing the key count of C[idx] and C[idx+1]\n    // respectively\n    child.n++;\n    sibling.n--;\n  }\n\n  // A function to merge C[idx] with C[idx+1]\n  // C[idx+1] is freed after merging\n  merge (idx:number, t:number) {\n    const n       = this.n;\n    const C       = this.C;\n    const keys    = this.keys;\n    const data    = this.data;\n    const child   = C[idx];\n    const sibling = C[idx + 1];\n\n    // Pulling a key from the current node and inserting it into (t-1)th\n    // position of C[idx]\n    child.keys[t - 1] = keys[idx];\n\n    // Copying the keys from C[idx+1] to C[idx] at the end\n    for (let i = 0; i < sibling.n; i++) {\n      child.keys[i + t] = sibling.keys[i];\n      child.data[i + t] = sibling.data[i];\n    }\n\n    // Copying the child pointers from C[idx+1] to C[idx]\n    if (!child.leaf) {\n      for (let i = 0; i <= sibling.n; i++) child.C[i + t] = sibling.C[i];\n    }\n\n    // Moving all keys after idx in the current node one step before -\n    // to fill the gap created by moving keys[idx] to C[idx]\n    for (let i = idx + 1; i < n; i++) {\n      keys[i - 1] = keys[i];\n      data[i - 1] = data[i];\n    }\n\n    // Moving the child pointers after (idx+1) in the current node one step before\n    for (let i = idx + 2; i <= n; i++) C[i - 1] = C[i];\n\n    // Updating the key count of child and the current node\n    child.n += sibling.n + 1;\n    this.n--;\n    return;\n  }\n\n\n  height():number {\n    if (this.leaf) return 1;\n    else {\n      let h = 0;\n      for (let i = 0; i < this.n; i++) {\n        h = Math.max(h, this.C[i].height());\n      }\n      return h + 1;\n    }\n  }\n};\n","/* Reference: CLRS3 - Chapter 18 - (499-502)\n  It is advised to read the material in CLRS before taking a look at the code.\n  */\n\nimport { Comparator, Key, Value, Visitor } from './types';\nimport BTreeNode from './btree_node';\n\nconst DEFAULT_COMPARATOR:Comparator<Key> = (a:Key, b:Key) => a - b;\n\nexport default class BTree<Key,Value> {\n\n  private root?:BTreeNode<Key,Value>;\n  private t:number;\n  private comparator:Comparator<Key>;\n\n  constructor(t:number = 8, comparator:Comparator<Key> = DEFAULT_COMPARATOR) {\n    this.root = null; // Pointer to root node\n    this.t = t;  // Minimum degree\n    this.comparator = comparator;\n  }\n\n  traverse (visitor:Visitor<Key,Value>):BTree<Key,Value> {\n    if (this.root !== null) this.root.traverse(visitor);\n    return this;\n  }\n\n  // function to search a key in this tree\n  search (k:Key) {\n    return (this.root === null) ? null : this.root.search(k, this.comparator);\n  }\n\n  // The main function that inserts a new key in this B-Tree\n  insert (k:Key, value:Value):BTree<Key,Value> {\n    const t = this.t;\n    // If tree is empty\n    if (this.root === null) {\n      // Allocate memory for root\n      this.root = new BTreeNode<Key,Value>(t, true);\n      this.root.keys[0] = k;  // Insert key\n      this.root.data[0] = value;\n      this.root.n = 1;  // Update number of keys in root\n    } else { // If tree is not empty\n      const root = this.root;\n      const comparator = this.comparator;\n      // If root is full, then tree grows in height\n      if (root.n === 2 * t - 1) {\n        // Allocate memory for new root\n        const s = new BTreeNode<Key,Value>(t, false);\n        // Make old root as child of new root\n        s.C[0] = root;\n\n        // Split the old root and move 1 key to the new root\n        s.splitChild(0, root, t);\n\n        // New root has two children now.  Decide which of the\n        // two children is going to have new key\n        let i = 0;\n        if (comparator(s.keys[0], k) < 0) i++;\n        s.C[i].insertNonFull(k, value, comparator, t);\n\n        // Change root\n        this.root = s;\n      } else {  // If root is not full, call insertNonFull for root\n        root.insertNonFull(k, value, comparator, t);\n      }\n    }\n    return this;\n  }\n\n  // The main function that removes a new key in thie B-Tree\n  remove (k:Key):BTree<Key,Value> {\n    if (this.root === null) {\n      throw new Error(\"The tree is empty\");\n    }\n\n    // Call the remove function for root\n    this.root.remove(k, this.comparator, this.t);\n\n    // If the root node has 0 keys, make its first child as the new root\n    //  if it has a child, otherwise set root as NULL\n    if (this.root.n === 0) {\n      const tmp = this.root;\n      if (this.root.leaf) this.root = null;\n      else                this.root = this.root.C[0];\n    }\n\n    return this;\n  }\n\n  height():number {\n    if (this.root === null) return 0;\n    return this.root.height();\n  }\n\n  keys(): Array<Key>  {\n    const keys:Array<Key> = [];\n    this.traverse((key:Key) => keys.push(key));\n    return keys;\n  }\n\n\n  entries(): Array<Value> {\n    const values:Array<Value> = [];\n    this.traverse((key:Key, value:Value) => values.push(value));\n    return values;\n  }\n}\n"],"names":[],"mappings":"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"}