{"version":3,"file":"btree.umd.js","sources":["../src/btree_node.ts","../src/btree.ts"],"sourcesContent":["import { Key, Value, Comparator, Visitor } from './types';\n\nexport default class BTreeNode<Key, Value> {\n\n  leaf: boolean;\n  keys: Array<Key>;\n  data: Array<Value>;\n  n: number;\n  C: Array<BTreeNode<Key,Value>>;\n\n  constructor (t:number, isLeaf:boolean) {\n    // Copy the given minimum degree and leaf property\n    this.leaf = isLeaf; // Is true when node is leaf. Otherwise false\n\n    // Allocate memory for maximum number of possible keys\n    // and child pointers\n    this.keys = new Array(2 * t - 1); // An array of keys\n    this.data = new Array(2 * t - 1);\n    this.C    = new Array(2 * t); // An array of child pointers\n\n    this.n    = 0; // Current number of keys\n  }\n\n\n  // Function to traverse all nodes in a subtree rooted with this node\n  traverse (visitor: Visitor<Key, Value>) {\n    // There are n keys and n+1 children, travers through n keys\n    // and first n children\n    const C    = this.C;\n    const keys = this.keys;\n    const data = this.data;\n    let i;\n    for (i = 0; i < this.n; i++) {\n      // If this is not leaf, then before printing key[i],\n      // traverse the subtree rooted with child C[i].\n      if (!this.leaf) C[i].traverse(visitor);\n      visitor(keys[i], data[i]);\n    }\n\n    // Print the subtree rooted with last child\n    if (!this.leaf) C[i].traverse(visitor);\n  }\n\n\n  // Function to search key k in subtree rooted with this node\n  search (key:Key, comparator: Comparator<Key>):BTreeNode<Key, Value> {\n    // Find the first key greater than or equal to k\n    let i = 0;\n    const keys = this.keys;\n    while (i < this.n && comparator(key, keys[i]) > 0) i++;\n\n    // If the found key is equal to k, return this node\n    if (comparator(keys[i], key) === 0) return this;\n\n    // If key is not found here and this is a leaf node\n    if (this.leaf) return null;\n\n    // Go to the appropriate child\n    return this.C[i].search(key, comparator);\n  }\n\n\n  // A utility function that returns the index of the first key that is\n  // greater than or equal to k\n  findKey (key:Key, comparator:Comparator<Key>):number {\n    let idx = 0;\n    while (idx < this.n && comparator(this.keys[idx], key) < 0) idx++;\n    return idx;\n  }\n\n\n  // A utility function to insert a new key in this node\n  // The assumption is, the node must be non-full when this\n  // function is called\n  insertNonFull (k:Key, value:Value, comparator:Comparator<Key>, t:number) {\n    // Initialize index as index of rightmost element\n    let i      = this.n - 1;\n    const keys = this.keys;\n    const data = this.data;\n    const C    = this.C;\n\n    // If this is a leaf node\n    if (this.leaf) {\n      // The following loop does two things\n      // a) Finds the location of new key to be inserted\n      // b) Moves all greater keys to one place ahead\n      while (i >= 0 && comparator(keys[i], k) > 0) {\n        keys[i + 1] = keys[i];\n        data[i + 1] = data[i];\n        i--;\n      }\n\n      // Insert the new key at found location\n      keys[i + 1] = k;\n      data[i + 1] = value;\n      this.n++;\n    } else { // If this node is not leaf\n      // Find the child which is going to have the new key\n      while (i >= 0 && comparator(keys[i], k) > 0) i--;\n\n      // See if the found child is full\n      if (C[i + 1].n === 2 * t - 1) {\n        // If the child is full, then split it\n        this.splitChild(i + 1, C[i + 1], t);\n        // After split, the middle key of C[i] goes up and\n        // C[i] is splitted into two.  See which of the two\n        // is going to have the new key\n        if (comparator(keys[i + 1], k) < 0) i++;\n      }\n      C[i + 1].insertNonFull(k, value, comparator, t);\n    }\n  }\n\n\n  // A utility function to split the child y of this node\n  // Note that y must be full when this function is called\n  splitChild (i:number, y:BTreeNode<Key,Value>, t:number) {\n    const n = this.n;\n    const C = this.C;\n    const data = this.data;\n    const keys = this.keys;\n\n    // Create a new node which is going to store (t-1) keys of y\n    const z = new BTreeNode<Key,Value>(t, y.leaf);\n    z.n = t - 1;\n\n    // Copy the last (t-1) keys of y to z\n    for (let j = 0; j < t - 1; j++) {\n      z.keys[j] = y.keys[j + t];\n      z.data[j] = y.data[j + t];\n    }\n\n    // Copy the last t children of y to z\n    if (!y.leaf) {\n      for (let j = 0; j < t; j++) z.C[j] = y.C[j + t];\n    }\n\n    // Reduce the number of keys in y\n    y.n = t - 1;\n\n    // Since this node is going to have a new child,\n    // create space of new child\n    for (let j = n; j >= i + 1; j--) C[j + 1] = C[j];\n\n    // Link the new child to this node\n    C[i + 1] = z;\n\n    // A key of y will move to this node. Find location of\n    // new key and move all greater keys one space ahead\n    for (let j = n - 1; j >= i; j--) {\n      keys[j + 1] = keys[j];\n      data[j + 1] = data[j];\n    }\n\n    // Copy the middle key of y to this node\n    keys[i] = y.keys[t - 1];\n    data[i] = y.data[t - 1];\n\n    // Increment count of keys in this node\n    this.n = n + 1;\n  }\n\n\n  // A function to remove the key k from the sub-tree rooted with this node\n  remove (k:Key, comparator:Comparator<Key>, t:number) {\n    let idx    = this.findKey(k, comparator);\n    const n    = this.n;\n    const keys = this.keys;\n    const C    = this.C;\n\n    // The key to be removed is present in this node\n    if (idx < n && comparator(keys[idx], k) === 0) {\n      // If the node is a leaf node - removeFromLeaf is called\n      // Otherwise, removeFromNonLeaf function is called\n      if (this.leaf) this.removeFromLeaf(idx);\n      else           this.removeFromNonLeaf(idx, comparator, t);\n    } else {\n\n      // If this node is a leaf node, then the key is not present in tree\n      if (this.leaf) throw new Error(`The key \"${k}\" is does not exist in the tree`);\n\n\n      // The key to be removed is present in the sub-tree rooted with this node\n      // The flag indicates whether the key is present in the sub-tree rooted\n      // with the last child of this node\n      const flag = (idx === n);\n\n      // If the child where the key is supposed to exist has less that t keys,\n      // we fill that child\n      if (C[idx].n < t) this.fill(idx, t);\n\n      // If the last child has been merged, it must have merged with the previous\n      // child and so we recurse on the (idx-1)th child. Else, we recurse on the\n      // (idx)th child which now has atleast t keys\n      if (flag && idx > n) C[idx - 1].remove(k, comparator, t);\n      else                 C[idx].remove(k, comparator, t);\n    }\n  }\n\n\n  // A function to remove the idx-th key from this node - which is a leaf node\n  removeFromLeaf (idx:number) {\n    // Move all the keys after the idx-th pos one place backward\n    const keys = this.keys;\n    const data = this.data;\n    for (let i = idx + 1; i < this.n; i++) {\n      keys[i - 1] = keys[i];\n      data[i - 1] = data[i];\n    }\n    // Reduce the count of keys\n    this.n--;\n  }\n\n\n  // A function to remove the idx-th key from this node - which is a non-leaf node\n  removeFromNonLeaf(idx:number, comparator:Comparator<Key>, t:number) {\n    const keys = this.keys;\n    const data = this.data;\n    const C    = this.C;\n\n    let k:Key   = keys[idx];\n\n\n    // If the child that precedes k (C[idx]) has atleast t keys,\n    // find the predecessor 'pred' of k in the subtree rooted at\n    // C[idx]. Replace k by pred. Recursively delete pred\n    // in C[idx]\n    if (C[idx].n >= t) {\n      let cur = C[idx];\n      while (!cur.leaf) cur = cur.C[cur.n];\n      const predKey  = cur.keys[cur.n - 1];\n      keys[idx] = predKey;\n      data[idx] = cur.data[cur.n - 1];\n      C[idx].remove(predKey, comparator, t);\n    } else if (C[idx + 1].n >= t) {\n      // If the child C[idx] has less that t keys, examine C[idx+1].\n      // If C[idx+1] has atleast t keys, find the successor 'succ' of k in\n      // the subtree rooted at C[idx+1]\n      // Replace k by succ\n      // Recursively delete succ in C[idx+1]\n      let cur = C[idx+1];\n      while (!cur.leaf) cur = cur.C[0];\n      // Return the first key of the leaf\n      const succKey = cur.keys[0];\n      const succData = cur.data[0];\n      keys[idx] = succKey;\n      data[idx] = cur.data[0];\n      C[idx + 1].remove(succKey, comparator, t);\n    } else {\n      // If both C[idx] and C[idx+1] has less that t keys,merge k and all of C[idx+1]\n      // into C[idx]\n      // Now C[idx] contains 2t-1 keys\n      // Free C[idx+1] and recursively delete k from C[idx]\n      this.merge(idx, t);\n      C[idx].remove(k, comparator, t);\n    }\n  }\n\n\n  // A function to get predecessor of keys[idx]\n  prev(idx:number):Key {\n    // Keep moving to the right most node until we reach a leaf\n    const C = this.C;\n    let cur = C[idx];\n    while (!cur.leaf) cur = cur.C[cur.n];\n    // Return the last key of the leaf\n    return cur.keys[cur.n - 1];\n  }\n\n\n  next(idx:number):Key {\n    // Keep moving the left most node starting from C[idx+1] until we reach a leaf\n    const C = this.C;\n    let cur = C[idx+1];\n    while (!cur.leaf) cur = cur.C[0];\n    // Return the first key of the leaf\n    return cur.keys[0];\n  }\n\n\n  // A function to fill child C[idx] which has less than t-1 keys\n  fill(idx:number, t:number) {\n    const n = this.n;\n    const C = this.C;\n    // If the previous child(C[idx-1]) has more than t-1 keys, borrow a key\n    // from that child\n    if (idx !== 0 && C[idx - 1].n >= t)      this.borrowFromPrev(idx);\n\n    // If the next child(C[idx+1]) has more than t-1 keys, borrow a key\n    // from that child\n    else if (idx !== n && C[idx + 1].n >= t) this.borrowFromNext(idx);\n\n    // Merge C[idx] with its sibling\n    // If C[idx] is the last child, merge it with with its previous sibling\n    // Otherwise merge it with its next sibling\n    else {\n      if (idx !== n) this.merge(idx,     t);\n      else           this.merge(idx - 1, t);\n    }\n  }\n\n\n  // A function to borrow a key from C[idx-1] and insert it\n  // into C[idx]\n  borrowFromPrev(idx:number) {\n    const C       = this.C;\n    const keys    = this.keys;\n    const data    = this.data;\n    const child   = C[idx];\n    const sibling = C[idx - 1];\n\n    // The last key from C[idx-1] goes up to the parent and key[idx-1]\n    // from parent is inserted as the first key in C[idx]. Thus, the  loses\n    // sibling one key and child gains one key\n\n    // Moving all key in C[idx] one step ahead\n    for (let i = child.n - 1; i >= 0; i--) {\n      child.keys[i + 1] = child.keys[i];\n      child.data[i + 1] = child.data[i];\n    }\n\n    // If C[idx] is not a leaf, move all its child pointers one step ahead\n    if (!child.leaf) {\n      for (let i = child.n; i >= 0; i--) child.C[i + 1] = child.C[i];\n    }\n\n    // Setting child's first key equal to keys[idx-1] from the current node\n    child.keys[0] = keys[idx - 1];\n    child.data[0] = data[idx - 1];\n\n    // Moving sibling's last child as C[idx]'s first child\n    if (!this.leaf) child.C[0] = sibling.C[sibling.n];\n\n    // Moving the key from the sibling to the parent\n    // This reduces the number of keys in the sibling\n    keys[idx - 1] = sibling.keys[sibling.n - 1];\n    data[idx - 1] = sibling.data[sibling.n - 1];\n\n    child.n++;\n    sibling.n--;\n  }\n\n  // A function to borrow a key from the C[idx+1] and place\n  // it in C[idx]\n  borrowFromNext (idx:number) {\n    const C       = this.C;\n    const keys    = this.keys;\n    const data    = this.data;\n\n    const child:BTreeNode<Key,Value>   = C[idx];\n    const sibling:BTreeNode<Key,Value> = C[idx + 1];\n\n    // keys[idx] is inserted as the last key in C[idx]\n    child.keys[child.n] = keys[idx];\n    child.data[child.n] = data[idx];\n\n    // Sibling's first child is inserted as the last child\n    // into C[idx]\n    if (!child.leaf) child.C[child.n + 1] = sibling.C[0];\n\n    //The first key from sibling is inserted into keys[idx]\n    keys[idx] = sibling.keys[0];\n    data[idx] = sibling.data[0];\n\n    // Moving all keys in sibling one step behind\n    for (let i = 1; i < sibling.n; i++) {\n      sibling.keys[i - 1] = sibling.keys[i];\n      sibling.data[i - 1] = sibling.data[i];\n    }\n\n    // Moving the child pointers one step behind\n    if (!sibling.leaf) {\n      for (let i = 1; i <= sibling.n; i++) sibling.C[i - 1] = sibling.C[i];\n    }\n\n    // Increasing and decreasing the key count of C[idx] and C[idx+1]\n    // respectively\n    child.n++;\n    sibling.n--;\n  }\n\n  // A function to merge C[idx] with C[idx+1]\n  // C[idx+1] is freed after merging\n  merge (idx:number, t:number) {\n    const n       = this.n;\n    const C       = this.C;\n    const keys    = this.keys;\n    const data    = this.data;\n    const child   = C[idx];\n    const sibling = C[idx + 1];\n\n    // Pulling a key from the current node and inserting it into (t-1)th\n    // position of C[idx]\n    child.keys[t - 1] = keys[idx];\n\n    // Copying the keys from C[idx+1] to C[idx] at the end\n    for (let i = 0; i < sibling.n; i++) {\n      child.keys[i + t] = sibling.keys[i];\n      child.data[i + t] = sibling.data[i];\n    }\n\n    // Copying the child pointers from C[idx+1] to C[idx]\n    if (!child.leaf) {\n      for (let i = 0; i <= sibling.n; i++) child.C[i + t] = sibling.C[i];\n    }\n\n    // Moving all keys after idx in the current node one step before -\n    // to fill the gap created by moving keys[idx] to C[idx]\n    for (let i = idx + 1; i < n; i++) {\n      keys[i - 1] = keys[i];\n      data[i - 1] = data[i];\n    }\n\n    // Moving the child pointers after (idx+1) in the current node one step before\n    for (let i = idx + 2; i <= n; i++) C[i - 1] = C[i];\n\n    // Updating the key count of child and the current node\n    child.n += sibling.n + 1;\n    this.n--;\n    return;\n  }\n};\n","/* Reference: CLRS3 - Chapter 18 - (499-502)\n  It is advised to read the material in CLRS before taking a look at the code.\n  */\n\nimport { Comparator, Key, Value, Visitor } from './types';\nimport BTreeNode from './btree_node';\n\nconst DEFAULT_COMPARATOR:Comparator<Key> = (a:Key, b:Key) => a - b;\n\nexport default class BTree<Key,Value> {\n\n  private root?:BTreeNode<Key,Value>;\n  private t:number;\n  private comparator:Comparator<Key>;\n\n  constructor(t:number = 8, comparator:Comparator<Key> = DEFAULT_COMPARATOR) {\n    this.root = null; // Pointer to root node\n    this.t = t;  // Minimum degree\n    this.comparator = comparator;\n  }\n\n  traverse (visitor:Visitor<Key,Value>):BTree<Key,Value> {\n    if (this.root !== null) this.root.traverse(visitor);\n    return this;\n  }\n\n  // function to search a key in this tree\n  search (k:Key) {\n    return (this.root === null) ? null : this.root.search(k, this.comparator);\n  }\n\n  // The main function that inserts a new key in this B-Tree\n  insert (k:Key, value:Value):BTree<Key,Value> {\n    const t = this.t;\n    // If tree is empty\n    if (this.root === null) {\n      // Allocate memory for root\n      this.root = new BTreeNode<Key,Value>(t, true);\n      this.root.keys[0] = k;  // Insert key\n      this.root.data[0] = value;\n      this.root.n = 1;  // Update number of keys in root\n    } else { // If tree is not empty\n      const root = this.root;\n      const comparator = this.comparator;\n      // If root is full, then tree grows in height\n      if (root.n === 2 * t - 1) {\n        // Allocate memory for new root\n        const s = new BTreeNode<Key,Value>(t, false);\n        // Make old root as child of new root\n        s.C[0] = root;\n\n        // Split the old root and move 1 key to the new root\n        s.splitChild(0, root, t);\n\n        // New root has two children now.  Decide which of the\n        // two children is going to have new key\n        let i = 0;\n        if (comparator(s.keys[0], k) < 0) i++;\n        s.C[i].insertNonFull(k, value, comparator, t);\n\n        // Change root\n        this.root = s;\n      } else {  // If root is not full, call insertNonFull for root\n        root.insertNonFull(k, value, comparator, t);\n      }\n    }\n    return this;\n  }\n\n  // The main function that removes a new key in thie B-Tree\n  remove (k:Key):BTree<Key,Value> {\n    if (this.root === null) {\n      throw new Error(\"The tree is empty\");\n    }\n\n    // Call the remove function for root\n    this.root.remove(k, this.comparator, this.t);\n\n    // If the root node has 0 keys, make its first child as the new root\n    //  if it has a child, otherwise set root as NULL\n    if (this.root.n === 0) {\n      const tmp = this.root;\n      if (this.root.leaf) this.root = null;\n      else                this.root = this.root.C[0];\n    }\n\n    return this;\n  }\n\n  keys(): Array<Key>  {\n    const keys:Array<Key> = [];\n    this.traverse((key:Key) => keys.push(key));\n    return keys;\n  }\n\n\n  entries(): Array<Value> {\n    const values:Array<Value> = [];\n    this.traverse((key:Key, value:Value) => values.push(value));\n    return values;\n  }\n}\n"],"names":[],"mappings":"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"}